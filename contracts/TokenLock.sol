// SPDX-License-Identifier: MIT
pragma solidity ^0.8.6;

import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract TokenLock is OwnableUpgradeable, IERC20 {
  ERC20 public token;
  uint256 public depositDeadline;
  uint256 public lockDuration;

  string public name;
  string public symbol;
  uint256 public override totalSupply;
  mapping(address => uint256) public override balanceOf;

  uint256 public constant ONE_DAY = 1 days; // TODO: For testing, remove later
  uint256 public constant THIRTY_DAYS = 30 days;
  uint256 public constant SIX_MONTHS = 180 days;
  uint256 public constant ONE_YEAR = 365 days;

  struct Lock {
    uint256 amount;
    uint256 lockTimestamp;
    uint256 lockDuration;
  }

  struct UserInfo {
    mapping(uint256 => Lock) locks; // LockID => Lock details
    uint256[] lockIds; // Track lock IDs for each user
  }

  mapping(address => UserInfo) private users; // User => UserInfo mapping

  /// Withdraw amount exceeds sender's balance of the locked token
  error ExceedsBalance();
  /// Lock period is not over yet
  error LockPeriodOngoing();
  /// Invalid lock duration
  error InvalidLockDuration();
  /// Could not transfer the designated ERC20 token
  error TransferFailed();
  /// ERC-20 function is not supported
  error NotSupported();

  event Deposit(address indexed user, uint256 indexed lockId, uint256 amount, uint256 lockDuration);
  event Withdraw(address indexed user, uint256 indexed lockId, uint256 amount);

  function initialize(
    address _owner,
    address _token,
    string memory _name,
    string memory _symbol
  ) public initializer {
    __Ownable_init();
    transferOwnership(_owner);
    token = ERC20(_token);
    name = _name;
    symbol = _symbol;
    totalSupply = 0;
  }

  /// @dev Deposit tokens with a predefined lock duration and LockID from the backend
  /// @param lockId The unique LockID generated by the backend
  /// @param amount The amount of tokens to deposit
  /// @param duration The lock duration (must be one of the predefined options)
  function deposit(uint256 lockId, uint256 amount, uint256 duration) public {
    require(amount > 0, "Deposit amount must be greater than 0");
    if (
        duration != ONE_DAY && // TODO: For testing, remove later
        duration != THIRTY_DAYS &&
        duration != SIX_MONTHS &&
        duration != ONE_YEAR
    ) {
        revert InvalidLockDuration();
    }
    // Update user's balance and lock information
    balanceOf[msg.sender] += amount;
    UserInfo storage user = users[msg.sender];
    totalSupply += amount;

    user.locks[lockId] = Lock({
        amount: amount,
        lockTimestamp: block.timestamp,
        lockDuration: duration
    });

    user.lockIds.push(lockId);

    _transferFromSender(amount);

    emit Deposit(msg.sender, lockId, amount, duration);
  }

  /// @dev Withdraw tokens after the lock period is over
  /// @param lockId The LockID for which the withdrawal is being made
  /// @param amount The amount of tokens to withdraw
  function withdraw(uint256 lockId, uint256 amount) public {
    UserInfo storage user = users[msg.sender];
    Lock storage userLock = user.locks[lockId];

    if (block.timestamp < userLock.lockTimestamp + userLock.lockDuration) {
      revert LockPeriodOngoing();
    }

    if (userLock.amount < amount) {
      revert ExceedsBalance();
    }

    userLock.amount -= amount;
    balanceOf[msg.sender] -= amount;
    totalSupply -= amount;

    _transferToSender(amount);

    emit Withdraw(msg.sender, lockId, amount);
  }

  /// @dev Returns the number of decimals of the locked token
  function decimals() public view returns (uint8) {
    return token.decimals();
  }

  /// @dev Get the locked amount for a specific user and lockId
  /// @param user The user's address
  /// @param lockId The LockID associated with the user's lock
  /// @return The amount of tokens locked for that LockID
  function getLockedAmount(address user, uint256 lockId) public view returns (uint256) {
    return users[user].locks[lockId].amount;
  }

  /// @dev Lock claim tokens are non-transferrable: ERC-20 transfer is not supported
  function transfer(address, uint256) external pure override returns (bool) {
    revert NotSupported();
  }

  /// @dev Lock claim tokens are non-transferrable: ERC-20 allowance is not supported
  function allowance(address, address)
    external
    pure
    override
    returns (uint256)
  {
    revert NotSupported();
  }

  /// @dev Lock claim tokens are non-transferrable: ERC-20 approve is not supported
  function approve(address, uint256) external pure override returns (bool) {
    revert NotSupported();
  }

  /// @dev Lock claim tokens are non-transferrable: ERC-20 transferFrom is not supported
  function transferFrom(
    address,
    address,
    uint256
  ) external pure override returns (bool) {
    revert NotSupported();
  }

  /// @dev Internal function to transfer tokens from sender to contract
  function _transferFromSender(uint256 amount) internal {
    if (!token.transferFrom(msg.sender, address(this), amount)) {
      revert TransferFailed();
    }
  }

  /// @dev Internal function to transfer tokens from contract to sender
  function _transferToSender(uint256 amount) internal {
    if (!token.transfer(msg.sender, amount)) {
      revert TransferFailed();
    }
  }
}